/*
 * This source file was generated by the Gradle 'init' task
 */
package clp.java;


import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;



public class App {

    private static final Logger logger = Logger.getLogger(App.class.getName());

    public static void main(String[] args) {
        App app = new App();
        CLPEncoder clpEncoder = new CLPEncoder();

        String[] testMessages = {"Started job_123 on node-987: 4 cores, 8 threads and 51.4% memory used.", "Can't fetch flow 6, cell_32", "Started job_123 on node-987: 4 cores"};
        // todo: why does Started job.* query get encoded to Started * instead of Started .*
        String[] testQueries = {"Started job.*", "Can't fetch flow.*", "node.*"};

        // encode each test message
        // and simulate search by encoding query to get possible subqueries
        // then match each subquery with stored message by checking the logtype, dictvars
        for (int i = 0; i < testMessages.length; i++) {
            String testMessage = testMessages[i];
            String testQuery = testQueries[i];
            
            // encode message to be stored
            CLPEncodedMessage encodedStoredMessage = clpEncoder.encode(testMessage).get();
            // encode query to get possible subqueries
            List<CLPEncodedMessage> encodedSubqueries = clpEncoder.encodeWildcardQuery(testQuery);

            // check if query matches stored message
            boolean hasAtLeastOneMatchingSubquery = false;
            for (CLPEncodedMessage encodedSubquery : encodedSubqueries) {
                // check if subquery's logtype matches stored message's logtype
                Pattern subqueryLogtypeRegexp = Pattern.compile(encodedSubquery.logtype);
                boolean hasMatchingLogType = subqueryLogtypeRegexp.matcher(encodedStoredMessage.logtype).matches();
                if (hasMatchingLogType) {
                    hasAtLeastOneMatchingSubquery = true;
                    break;
                }

                // check if subquery's logtype matches stired message's dictvars
                boolean doesSubqueryLogTypeMatchDictVar = Arrays.stream(encodedStoredMessage.dictVars).filter(storedDictVar -> subqueryLogtypeRegexp.matcher(storedDictVar).matches()).findFirst().isPresent();
                if (doesSubqueryLogTypeMatchDictVar) {
                    hasAtLeastOneMatchingSubquery = true;
                    break;
                }

                // check if subquery's dictvars match stored message's dictvars
                // we do so by checking if there is at least one common element between the two sets using set intersection
                Set<String> encodedStoredMessageDictVars = new HashSet<>(Arrays.asList(encodedStoredMessage.dictVars));
                Set<String> encodedSubqueryDictVars = new HashSet<>(Arrays.asList(encodedSubquery.dictVars));
                boolean hasAtLeastOneMatchingDictVar = encodedStoredMessageDictVars.stream().filter(encodedSubqueryDictVars::contains).findFirst().isPresent();
                if (hasAtLeastOneMatchingDictVar) {
                    hasAtLeastOneMatchingSubquery = true;
                    break;
                }
            }

            logger.log(Level.INFO, "main | encodedStoredMessage={0}, encodedSubqueries={1}, hasAtLeastOneMatchingSubquery={2}", new Object[]{encodedStoredMessage, encodedSubqueries, hasAtLeastOneMatchingSubquery});

            // assert that query matches the stored message
            assert hasAtLeastOneMatchingSubquery == true;
        }
    }
}
