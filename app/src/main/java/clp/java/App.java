/*
 * This source file was generated by the Gradle 'init' task
 */
package clp.java;


import org.apache.commons.lang3.ArrayUtils;
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import com.yscope.clp.compressorfrontend.BuiltInVariableHandlingRuleVersions;
import com.yscope.clp.compressorfrontend.EncodedMessage;
import com.yscope.clp.compressorfrontend.MessageEncoder;
import com.yscope.clp.compressorfrontend.AbstractClpEncodedSubquery.VariableWildcardQuery;
import com.yscope.clp.compressorfrontend.BuiltInVariableHandlingRuleVersions;
import com.yscope.clp.compressorfrontend.ByteSegment;
import com.yscope.clp.compressorfrontend.ByteSegments;
import com.yscope.clp.compressorfrontend.EightByteClpEncodedSubquery;
import com.yscope.clp.compressorfrontend.EightByteClpWildcardQueryEncoder;


public class App {
    public class Result {
        String logtype;
        long[] encodedVars;
        String[] dictVars;

        @Override
        public String toString() {
            return "Result [logtype=" + logtype + ", encodedVars=" + Arrays.toString(encodedVars) + ", dictVars=" + Arrays.toString(dictVars) + "]";
        }

        public Result(String logtype, long[] encodedVars, String[] dictVars) {
            this.logtype = logtype;
            this.encodedVars = encodedVars;
            this.dictVars = dictVars;
        }

        public Result(String logtype, long[] encodedVars, ByteSegments dictVars) {
            this.logtype = logtype;
            this.encodedVars = encodedVars;
            ArrayList<String> dictVarsStrings = new ArrayList<>();
            for (ByteSegment byteSegment : dictVars) {
                dictVarsStrings.add(byteSegment.toString());
            }
            this.dictVars =dictVarsStrings.toArray());
        }
    }

    private Result encode(String valueToEncode) {
        MessageEncoder _clpMessageEncoder = new MessageEncoder(BuiltInVariableHandlingRuleVersions.VariablesSchemaV2, BuiltInVariableHandlingRuleVersions.VariableEncodingMethodsV1);
        EncodedMessage _clpEncodedMessage = new EncodedMessage();

        try {
            System.out.printf("Encoding message=%s, schema=%s, varHandling=%s\n", valueToEncode, BuiltInVariableHandlingRuleVersions.VariablesSchemaV2, BuiltInVariableHandlingRuleVersions.VariableEncodingMethodsV1);
            _clpMessageEncoder.encodeMessage(valueToEncode, _clpEncodedMessage);

            String logtype = _clpEncodedMessage.getLogTypeAsString();
            long[] encodedVars = ArrayUtils.toPrimitive(_clpEncodedMessage.getEncodedVarsAsBoxedLongs());
            String[] dictVars = _clpEncodedMessage.getDictionaryVarsAsStrings();

            System.out.printf("encode | valueToEncode=%s,encoded=%s\n", valueToEncode, _clpEncodedMessage);

            return new Result(logtype, encodedVars, dictVars);
        } catch (Exception e) {
            e.printStackTrace(System.out);
        }
        
    }

    private List<Result> encodeWildcardQuery(String wildcardQuery) {
        EightByteClpWildcardQueryEncoder queryEncoder = new EightByteClpWildcardQueryEncoder(BuiltInVariableHandlingRuleVersions.VariablesSchemaV2, BuiltInVariableHandlingRuleVersions.VariableEncodingMethodsV1);
        EightByteClpEncodedSubquery[] subqueries = queryEncoder.encode(wildcardQuery);
        List<Result> results = new ArrayList<>();
        for (EightByteClpEncodedSubquery subquery : subqueries) {
            String logtype = subquery.getLogtypeQueryAsString();
            long[] encodedVars = subquery.getEncodedVars();
            ByteSegments dictVars = subquery.getDictVars();
            System.out.printf("encodeWildcardQuery | wildcardQuery=%s,encoded=%s\n", wildcardQuery, subquery);
            results.add(new Result(logtype, encodedVars, dictVars));
        }
        return results;
    }


    public static void main(String[] args) {
        App app = new App();
        String[] testMessages = {"Started job_123 on node-987: 4 cores, 8 threads and 51.4% memory used.", "Can't fetch flow 6, cell_32"};
        String[] testQueries = {"Started job_*", "Can't fetch flow*"};

        // encode each test message
        // and simulate search by encoding query to get possible subqueries
        // then match each subquery with stored message by checking the logtype, dictvars
        for (int i = 0; i <= testMessages.length; i++) {
            String testMessage = testMessages[i];
            String testQuery = testQueries[i];
            Result encodedStoredMessage = app.encode(testMessage);
            List<Result> encodedSubqueries = app.encodeWildcardQuery(testQuery);

            boolean hasAtLeastOneMatchingSubquery = false;
            for (Result encodedSubquery : encodedSubqueries) {
                System.out.printf("encodeWildcardQuery | wildcardQuery=%s,encoded=%s\n", testQuery, encodedSubquery);

                Pattern subqueryRegexp = Pattern.compile(encodedSubquery.logtype);
                Matcher subqueryRegexpMatch = subqueryRegexp.matcher(encodedStoredMessage.logtype);
                if (subqueryRegexpMatch.matches()) {
                    hasAtLeastOneMatchingSubquery = true;
                    break;
                }

                // TODO: check if dict vars match
            }

            assert hasAtLeastOneMatchingSubquery == true;
        }
        
    }
}
